/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/eioannidis/karamel/krml -skip-compilation -skip-makefiles -skip-linking -warn-error -15-4-2 -tmpdir _c_output -library Pulse.Lib.Vector _krml_output/Pulse_Lib_RangeVec.krml _krml_output/Pulse_Lib_Vector.krml
  F* version: <unknown>
  KaRaMeL version: a4caa585
 */

#include "Pulse_Lib_RangeVec.h"

Pulse_Lib_RangeVec_range
Pulse_Lib_RangeVec_default_range = { .start = (size_t)0U, .len = (size_t)1U };

Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
*Pulse_Lib_RangeVec_range_vec_create(void)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
  *rv = Pulse_Lib_Vector_create(Pulse_Lib_RangeVec_default_range, (size_t)1U);
  Pulse_Lib_Vector_pop_back(rv, (void *)0U, (void *)0U);
  return rv;
}

void
Pulse_Lib_RangeVec_range_vec_free(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv
)
{
  Pulse_Lib_Vector_free(rv, (void *)0U, (void *)0U);
}

size_t
Pulse_Lib_RangeVec_range_vec_contiguous_from(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t base
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  if (sz == (size_t)0U)
    return (size_t)0U;
  else
  {
    Pulse_Lib_RangeVec_range first = Pulse_Lib_Vector_at(rv, (size_t)0U, (void *)0U, (void *)0U);
    size_t r_high = first.start + first.len;
    if (first.start <= base && base < r_high)
      return r_high - base;
    else
      return (size_t)0U;
  }
}

size_t
Pulse_Lib_RangeVec_range_vec_max_endpoint(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  if (sz == (size_t)0U)
    return (size_t)0U;
  else
  {
    size_t last_idx = sz - (size_t)1U;
    Pulse_Lib_RangeVec_range last = Pulse_Lib_Vector_at(rv, last_idx, (void *)0U, (void *)0U);
    return last.start + last.len;
  }
}

void
Pulse_Lib_RangeVec_vec_insert_at(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t i,
  Pulse_Lib_RangeVec_range r
)
{
  Pulse_Lib_Vector_push_back(rv, r, (void *)0U, (void *)0U);
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  if (sz > (size_t)1U && i < sz - (size_t)1U)
  {
    size_t j = sz - (size_t)1U;
    bool cont = true;
    while (cont)
    {
      size_t jv = j;
      if (jv > i)
      {
        Pulse_Lib_RangeVec_range
        prev = Pulse_Lib_Vector_at(rv, jv - (size_t)1U, (void *)0U, (void *)0U);
        Pulse_Lib_Vector_set(rv, jv, prev, (void *)0U, (void *)0U);
        size_t new_j = jv - (size_t)1U;
        j = new_j;
        if (new_j == i)
          cont = false;
      }
      else
        cont = false;
    }
    Pulse_Lib_Vector_set(rv, i, r, (void *)0U, (void *)0U);
  }
}

void
Pulse_Lib_RangeVec_vec_remove_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t i,
  size_t count
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  size_t dst_end = sz - count;
  size_t j = i;
  bool shift_cont = true;
  while (shift_cont)
  {
    size_t jv = j;
    if (jv < dst_end)
    {
      Pulse_Lib_RangeVec_range val_ = Pulse_Lib_Vector_at(rv, jv + count, (void *)0U, (void *)0U);
      Pulse_Lib_Vector_set(rv, jv, val_, (void *)0U, (void *)0U);
      j = jv + (size_t)1U;
    }
    else
      shift_cont = false;
  }
  size_t k = (size_t)0U;
  bool pop_cont = true;
  while (pop_cont)
  {
    size_t kv = k;
    if (kv < count)
    {
      Pulse_Lib_Vector_pop_back(rv, (void *)0U, (void *)0U);
      size_t new_k = kv + (size_t)1U;
      k = new_k;
      if (new_k == count)
        pop_cont = false;
    }
    else
      pop_cont = false;
  }
}

void
Pulse_Lib_RangeVec_range_vec_add(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t offset,
  size_t len
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  size_t off_plus_len = offset + len;
  size_t idx = (size_t)0U;
  bool search = true;
  while (search)
  {
    size_t iv = idx;
    if (iv < sz)
    {
      Pulse_Lib_RangeVec_range r = Pulse_Lib_Vector_at(rv, iv, (void *)0U, (void *)0U);
      size_t high = r.start + r.len;
      if (high < offset)
        idx = iv + (size_t)1U;
      else
        search = false;
    }
    else
      search = false;
  }
  size_t iv = idx;
  if (sz == (size_t)0U || iv == sz)
  {
    Pulse_Lib_RangeVec_range r = { .start = offset, .len = len };
    Pulse_Lib_RangeVec_vec_insert_at(rv, iv, r);
  }
  else
  {
    Pulse_Lib_RangeVec_range first_r = Pulse_Lib_Vector_at(rv, iv, (void *)0U, (void *)0U);
    if (off_plus_len < first_r.start)
      Pulse_Lib_RangeVec_vec_insert_at(rv,
        iv,
        ((Pulse_Lib_RangeVec_range){ .start = offset, .len = len }));
    else
    {
      size_t first_high = first_r.start + first_r.len;
      size_t ite;
      if (off_plus_len > first_high)
        ite = off_plus_len;
      else
        ite = first_high;
      size_t merged_high = ite;
      size_t j = iv + (size_t)1U;
      bool merge_cont = true;
      while (merge_cont)
      {
        size_t jv = j;
        if (jv < sz)
        {
          Pulse_Lib_RangeVec_range r = Pulse_Lib_Vector_at(rv, jv, (void *)0U, (void *)0U);
          size_t mh = merged_high;
          if (mh >= r.start)
          {
            size_t r_high = r.start + r.len;
            if (r_high > mh)
              merged_high = r_high;
            j = jv + (size_t)1U;
          }
          else
            merge_cont = false;
        }
        else
          merge_cont = false;
      }
    }
  }
}

