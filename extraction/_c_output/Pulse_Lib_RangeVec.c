/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/eioannidis/karamel/krml -skip-compilation -skip-makefiles -skip-linking -bundle Pulse_Lib_RangeVec=Pulse.Lib.RangeVec,Pulse.Lib.Vector -warn-error -15-4-2 -tmpdir extraction/_c_output extraction/_output/Pulse_Lib_RangeVec.krml extraction/_output/Pulse_Lib_Vector.krml
  F* version: <unknown>
  KaRaMeL version: a4caa585
 */

#include "Pulse_Lib_RangeVec.h"

Pulse_Lib_RangeVec_range
Pulse_Lib_RangeVec_default_range = { .start = (size_t)0U, .len = (size_t)1U };

static Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
*create__Pulse_Lib_RangeVec_range(Pulse_Lib_RangeVec_range default0, size_t n)
{
  KRML_CHECK_SIZE(sizeof (Pulse_Lib_RangeVec_range), n);
  Pulse_Lib_RangeVec_range arr[n];
  for (uint32_t _i = 0U; _i < n; ++_i)
    arr[_i] = default0;
  size_t n_ = n;
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
  vi = { .arr = arr, .sz = n_, .cap = n_, .default_val = default0 };
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
  *buf = KRML_HOST_MALLOC(sizeof (Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range));
  if (buf != NULL)
    buf[0U] = vi;
  return buf;
}

static Pulse_Lib_RangeVec_range
pop_back__Pulse_Lib_RangeVec_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *v
)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range vi_val = *v;
  size_t last_idx = vi_val.sz - (size_t)1U;
  Pulse_Lib_RangeVec_range x = vi_val.arr[last_idx];
  size_t new_sz = last_idx;
  size_t half_cap = vi_val.cap / (size_t)2U;
  bool should_shrink = half_cap > (size_t)0U && new_sz == half_cap;
  if (should_shrink)
  {
    KRML_CHECK_SIZE(sizeof (Pulse_Lib_RangeVec_range), half_cap);
    Pulse_Lib_RangeVec_range new_arr[half_cap];
    for (uint32_t _i = 0U; _i < half_cap; ++_i)
      new_arr[_i] = vi_val.default_val;
    Pulse_Lib_Array_memcpy_l(new_sz, vi_val.arr, new_arr, (void *)0U, (void *)0U, (void *)0U);
    Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
    new_vi = { .arr = new_arr, .sz = new_sz, .cap = half_cap, .default_val = vi_val.default_val };
    *v = new_vi;
    return x;
  }
  else
  {
    Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
    new_vi =
      { .arr = vi_val.arr, .sz = new_sz, .cap = vi_val.cap, .default_val = vi_val.default_val };
    *v = new_vi;
    return x;
  }
}

Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
*Pulse_Lib_RangeVec_range_vec_create(void)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
  *rv = create__Pulse_Lib_RangeVec_range(Pulse_Lib_RangeVec_default_range, (size_t)1U);
  pop_back__Pulse_Lib_RangeVec_range(rv);
  return rv;
}

static void
free__Pulse_Lib_RangeVec_range(Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *v)
{
  KRML_HOST_FREE(v);
}

void
Pulse_Lib_RangeVec_range_vec_free(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv
)
{
  free__Pulse_Lib_RangeVec_range(rv);
}

static size_t
size__Pulse_Lib_RangeVec_range(Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *v)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range vi_val = *v;
  return vi_val.sz;
}

static Pulse_Lib_RangeVec_range
at__Pulse_Lib_RangeVec_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *v,
  size_t i
)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range vi_val = *v;
  return vi_val.arr[i];
}

size_t
Pulse_Lib_RangeVec_range_vec_contiguous_from(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t base
)
{
  size_t sz = size__Pulse_Lib_RangeVec_range(rv);
  if (sz == (size_t)0U)
    return (size_t)0U;
  else
  {
    Pulse_Lib_RangeVec_range first = at__Pulse_Lib_RangeVec_range(rv, (size_t)0U);
    size_t r_high = first.start + first.len;
    if (first.start <= base && base < r_high)
      return r_high - base;
    else
      return (size_t)0U;
  }
}

size_t
Pulse_Lib_RangeVec_range_vec_max_endpoint(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv
)
{
  size_t sz = size__Pulse_Lib_RangeVec_range(rv);
  if (sz == (size_t)0U)
    return (size_t)0U;
  else
  {
    size_t last_idx = sz - (size_t)1U;
    Pulse_Lib_RangeVec_range last = at__Pulse_Lib_RangeVec_range(rv, last_idx);
    return last.start + last.len;
  }
}

static void
push_back__Pulse_Lib_RangeVec_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *v,
  Pulse_Lib_RangeVec_range x
)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range vi_val = *v;
  if (vi_val.sz < vi_val.cap)
  {
    vi_val.arr[vi_val.sz] = x;
    Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
    new_vi =
      {
        .arr = vi_val.arr,
        .sz = vi_val.sz + (size_t)1U,
        .cap = vi_val.cap,
        .default_val = vi_val.default_val
      };
    *v = new_vi;
  }
  else
  {
    size_t new_cap = vi_val.cap + vi_val.cap;
    KRML_CHECK_SIZE(sizeof (Pulse_Lib_RangeVec_range), new_cap);
    Pulse_Lib_RangeVec_range new_arr[new_cap];
    for (uint32_t _i = 0U; _i < new_cap; ++_i)
      new_arr[_i] = vi_val.default_val;
    Pulse_Lib_Array_memcpy_l(vi_val.cap, vi_val.arr, new_arr, (void *)0U, (void *)0U, (void *)0U);
    new_arr[vi_val.sz] = x;
    Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
    new_vi =
      {
        .arr = new_arr,
        .sz = vi_val.sz + (size_t)1U,
        .cap = new_cap,
        .default_val = vi_val.default_val
      };
    *v = new_vi;
  }
}

static void
set__Pulse_Lib_RangeVec_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *v,
  size_t i,
  Pulse_Lib_RangeVec_range x
)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range vi_val = *v;
  vi_val.arr[i] = x;
}

void
Pulse_Lib_RangeVec_vec_insert_at(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t i,
  Pulse_Lib_RangeVec_range r
)
{
  push_back__Pulse_Lib_RangeVec_range(rv, r);
  size_t sz = size__Pulse_Lib_RangeVec_range(rv);
  if (sz > (size_t)1U && i < sz - (size_t)1U)
  {
    size_t j = sz - (size_t)1U;
    bool cont = true;
    while (cont)
    {
      size_t jv = j;
      if (jv > i)
      {
        Pulse_Lib_RangeVec_range prev = at__Pulse_Lib_RangeVec_range(rv, jv - (size_t)1U);
        set__Pulse_Lib_RangeVec_range(rv, jv, prev);
        size_t new_j = jv - (size_t)1U;
        j = new_j;
        if (new_j == i)
          cont = false;
      }
      else
        cont = false;
    }
    set__Pulse_Lib_RangeVec_range(rv, i, r);
  }
}

void
Pulse_Lib_RangeVec_vec_remove_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t i,
  size_t count
)
{
  size_t sz = size__Pulse_Lib_RangeVec_range(rv);
  size_t dst_end = sz - count;
  size_t j = i;
  bool shift_cont = true;
  while (shift_cont)
  {
    size_t jv = j;
    if (jv < dst_end)
    {
      Pulse_Lib_RangeVec_range val_ = at__Pulse_Lib_RangeVec_range(rv, jv + count);
      set__Pulse_Lib_RangeVec_range(rv, jv, val_);
      j = jv + (size_t)1U;
    }
    else
      shift_cont = false;
  }
  size_t k = (size_t)0U;
  bool pop_cont = true;
  while (pop_cont)
  {
    size_t kv = k;
    if (kv < count)
    {
      pop_back__Pulse_Lib_RangeVec_range(rv);
      size_t new_k = kv + (size_t)1U;
      k = new_k;
      if (new_k == count)
        pop_cont = false;
    }
    else
      pop_cont = false;
  }
}

void
Pulse_Lib_RangeVec_range_vec_add(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t offset,
  size_t len
)
{
  size_t sz = size__Pulse_Lib_RangeVec_range(rv);
  size_t off_plus_len = offset + len;
  size_t idx = (size_t)0U;
  bool search = true;
  while (search)
  {
    size_t iv = idx;
    if (iv < sz)
    {
      Pulse_Lib_RangeVec_range r = at__Pulse_Lib_RangeVec_range(rv, iv);
      size_t high = r.start + r.len;
      if (high < offset)
        idx = iv + (size_t)1U;
      else
        search = false;
    }
    else
      search = false;
  }
  size_t iv = idx;
  if (!(sz == (size_t)0U || iv == sz))
  {
    Pulse_Lib_RangeVec_range first_r = at__Pulse_Lib_RangeVec_range(rv, iv);
    if (!(off_plus_len < first_r.start))
    {
      size_t first_high = first_r.start + first_r.len;
      size_t ite;
      if (off_plus_len > first_high)
        ite = off_plus_len;
      else
        ite = first_high;
      size_t merged_high = ite;
      size_t j = iv + (size_t)1U;
      bool merge_cont = true;
      while (merge_cont)
      {
        size_t jv = j;
        if (jv < sz)
        {
          Pulse_Lib_RangeVec_range r = at__Pulse_Lib_RangeVec_range(rv, jv);
          size_t mh = merged_high;
          if (mh >= r.start)
          {
            size_t r_high = r.start + r.len;
            if (r_high > mh)
              merged_high = r_high;
            j = jv + (size_t)1U;
          }
          else
            merge_cont = false;
        }
        else
          merge_cont = false;
      }
    }
  }
}

