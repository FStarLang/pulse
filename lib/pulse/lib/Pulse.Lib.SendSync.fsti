module Pulse.Lib.SendSync
open Pulse.Lib.Core
open Pulse.Class.Duplicable
open Pulse.Main
module T = FStar.Tactics.V2
#lang-pulse

[@@Tactics.Typeclasses.tcclass; erasable]
type is_send_across (#b:Type0) (g: loc_id -> b) (p: slprop) =
  l:loc_id -> l':loc_id { g l == g l' } -> stt_ghost unit emp_inames (on l p) (fun _ -> on l' p)

irreducible let anywhere (l: loc_id) = ()

[@@Tactics.Typeclasses.tcclass; erasable]
type placeless (p: slprop) =
  is_send_across anywhere p

ghost fn ghost_impersonate
    (#[T.exact (`emp_inames)] is: inames)
    (l: loc_id) (pre post: slprop) {| placeless pre, placeless post |}
    (f: unit -> stt_ghost unit is (loc l ** pre) (fun _ -> loc l ** post))
  opens is
  requires pre
  ensures post

ghost fn placeless_move (p: slprop) {| placeless p |} l1 l2
  requires on l1 p
  ensures on l2 p

ghost fn placeless_on_intro (p: slprop) {| placeless p |} l
  requires p
  ensures on l p

ghost fn placeless_on_elim (p: slprop) {| placeless p |} l
  requires on l p
  ensures p

ghost fn on_pure_elim l p
  requires on l (pure p)
  ensures pure p

ghost fn on_star_elim #l (p q: slprop)
  requires on l (p ** q)
  ensures on l p
  ensures on l q

ghost fn on_star_intro #l (p q: slprop)
  requires on l p
  requires on l q
  ensures on l (p ** q)

instance val placeless_on (l: loc_id) (p: slprop) : placeless (on l p)
instance val placeless_emp : placeless emp
instance val placeless_star (a b: slprop) {| placeless a, placeless b |} : placeless (a ** b)
instance val placeless_pure (p: prop) : placeless (pure p)
instance val placeless_later_credit amt : placeless (later_credit amt)
instance val placeless_equiv a b : placeless (equiv a b)
instance val placeless_slprop_ref_pts_to x y : placeless (slprop_ref_pts_to x y)
instance val placeless_exists #a (p: a -> slprop) {| ((x:a) -> placeless (p x)) |} :
  placeless (exists* x. p x)

ghost fn on_exists_elim u#a #l (#a: Type u#a) (p: a -> slprop)
  requires on l (exists* x. p x)
  ensures exists* x. on l (p x)

let in_same_process p = exists* l. loc l ** pure (process_of l == process_of p)
val timeless_in_same_process p : Lemma (timeless (in_same_process p)) [SMTPat (timeless (in_same_process p))]
instance val duplicable_in_same_process p : duplicable (in_same_process p)

[@@Tactics.Typeclasses.tcclass; erasable]
let is_send p = is_send_across process_of p

ghost fn is_send_across_elim #b (g: loc_id -> b) p {| inst: is_send_across g p |} #l l'
  requires on l p
  requires pure (g l == g l')
  ensures on l' p

ghost fn is_send_elim p {| inst: is_send p |} #l l'
  requires on l p
  requires pure (process_of l == process_of l')
  ensures on l' p

ghost fn is_send_elim_on p {| is_send p |} #l
  preserves in_same_process l
  requires on l p
  ensures p

ghost fn is_send_intro_on p {| is_send p |} l
  preserves in_same_process l
  requires p
  ensures on l p

ghost fn is_send_elim_on' p {| is_send p |} #l
  preserves loc l
  requires on (process_of l) p
  ensures p

ghost fn is_send_intro_on' p {| is_send p |} l
  preserves loc l
  requires p
  ensures on (process_of l) p

instance val is_send_across_placeless #b #g p {| inst: placeless p |} : is_send_across #b g p
instance val is_send_across_star #b #g p q {| is_send_across #b g p, is_send_across #b g q |} : is_send_across g (p ** q)
instance val is_send_across_exists #b #g #a (p: a->slprop) {| ((x:a) -> is_send_across #b g (p x)) |} :
  is_send_across g (exists* x. p x)

instance is_send_placeless p {| inst: placeless p |} : is_send p = is_send_across_placeless p
instance val is_send_in_same_process p : is_send (in_same_process p)
instance is_send_star p q {| ip: is_send p, iq: is_send q |} : is_send (p ** q) = is_send_across_star p q #ip #iq
instance is_send_exists #a (p: a->slprop) {| i: ((x:a) -> is_send (p x)) |} :
  is_send (exists* x. p x) = is_send_across_exists p #i

val on_same_process (p: slprop) : slprop
ghost fn on_same_process_elim p {| is_send p |}
  requires on_same_process p
  ensures p
ghost fn on_same_process_intro p
  requires p
  ensures on_same_process p
val timeless_on_same_process (p: timeless_slprop) :
  Lemma (timeless (on_same_process p)) [SMTPat (timeless (on_same_process p))]
instance val is_send_on_same_process p : is_send (on_same_process p)

val sendable (p: slprop) : slprop
ghost fn sendable_elim p
  requires sendable p
  ensures p
ghost fn sendable_intro p {| is_send p |}
  requires p
  ensures sendable p
instance val is_send_sendable p : is_send (sendable p)

inline_for_extraction noextract fn fork'
  (pre:slprop) {| is_send pre |}
  (f: (unit -> stt unit pre (fun _ -> emp)))
  requires pre