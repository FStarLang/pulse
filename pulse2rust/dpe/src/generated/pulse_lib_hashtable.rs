////
////
//// This file is generated by the Pulse2Rust tool
////
////

pub fn mk_used_cell<A: Copy + PartialEq + Clone, B: Clone>(
    k: A,
    v: B,
) -> super::pulse_lib_hashtable_spec::cell<A, B> {
    super::pulse_lib_hashtable_spec::cell::Used(k, v)
}
pub fn mk_ht<K: Copy + PartialEq + Clone, V: Clone>(
    sz: super::pulse_lib_hashtable_type::pos_us,
    hashf: fn(K) -> usize,
    contents: std::vec::Vec<super::pulse_lib_hashtable_spec::cell<K, V>>,
) -> super::pulse_lib_hashtable_type::ht_t<K, V> {
    super::pulse_lib_hashtable_type::ht_t {
        sz: sz,
        hashf: hashf,
        contents: contents,
    }
}
pub fn alloc<K: Copy + PartialEq + Clone, V: Clone>(
    hashf: fn(K) -> usize,
    l: super::pulse_lib_hashtable_type::pos_us,
) -> super::pulse_lib_hashtable_type::ht_t<K, V> {
    let mut contents = vec![super::pulse_lib_hashtable_spec::cell::Clean; l];
    let ht = super::pulse_lib_hashtable::mk_ht(l, hashf, contents);
    ht
}
pub fn size_t_mod(x: usize, y: usize) -> usize {
    x % y
}
pub fn lookup<KT: Copy + PartialEq + Clone, VT: Clone>(
    pht: (),
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, std::option::Option<usize>) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let cidx = super::pulse_lib_hashtable::size_t_mod(hashf(k), ht.sz);
    let mut off = 0;
    let mut cont = true;
    let mut ret = None;
    while {
        let voff = off;
        let vcont = cont;
        voff <= ht.sz && vcont == true
    } {
        let voff = off;
        if voff == ht.sz {
            cont = false
        } else {
            let sum = cidx + voff;
            let idx = super::pulse_lib_hashtable::size_t_mod(sum, ht.sz);
            let c = std::mem::replace::<
                super::pulse_lib_hashtable_spec::cell<KT, VT>,
            >(&mut contents[idx], super::pulse_lib_hashtable_spec::cell::Zombie);
            match c {
                super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_) => {
                    if k_ == k {
                        cont = false;
                        ret = Some(idx);
                        let uu___3 = std::mem::replace::<
                            super::pulse_lib_hashtable_spec::cell<KT, VT>,
                        >(
                            &mut contents[idx],
                            super::pulse_lib_hashtable_spec::cell::Used(k_, v_),
                        );
                    } else {
                        off = voff + 1;
                        let uu___2 = std::mem::replace::<
                            super::pulse_lib_hashtable_spec::cell<KT, VT>,
                        >(
                            &mut contents[idx],
                            super::pulse_lib_hashtable_spec::cell::Used(k_, v_),
                        );
                    }
                }
                super::pulse_lib_hashtable_spec::cell::Clean => {
                    cont = false;
                    let uu___2 = std::mem::replace::<
                        super::pulse_lib_hashtable_spec::cell<KT, VT>,
                    >(&mut contents[idx], c);
                }
                super::pulse_lib_hashtable_spec::cell::Zombie => {
                    off = voff + 1;
                    let uu___2 = std::mem::replace::<
                        super::pulse_lib_hashtable_spec::cell<KT, VT>,
                    >(&mut contents[idx], c);
                }
            }
        }
    }
    let o = ret;
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, ht.hashf, vcontents);
    let res = (ht1, o);
    let ret1 = res;
    let cont1 = ret1;
    let off1 = cont1;
    let contents1 = off1;
    contents1
}
pub fn replace<KT: Copy + PartialEq + Clone, VT: Clone>(
    pht: (),
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    idx: usize,
    k: KT,
    v: VT,
    uu___: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, VT) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let v_ = std::mem::replace::<
        super::pulse_lib_hashtable_spec::cell<KT, VT>,
    >(&mut contents[idx], super::pulse_lib_hashtable::mk_used_cell(k, v));
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
    let _bind_c = match v_ {
        super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_1) => {
            let res = (ht1, v_1);
            res
        }
        super::pulse_lib_hashtable_spec::cell::Clean => panic!(),
        super::pulse_lib_hashtable_spec::cell::Zombie => panic!(),
    };
    let contents1 = _bind_c;
    contents1
}
pub fn insert<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
    v: VT,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let cidx = super::pulse_lib_hashtable::size_t_mod(hashf(k), ht.sz);
    let mut off = 0;
    let mut cont = true;
    let mut idx = 0;
    while {
        let vcont = cont;
        vcont == true
    } {
        let voff = off;
        if voff == ht.sz {
            panic!()
        } else {
            let sum = cidx + voff;
            let vidx = super::pulse_lib_hashtable::size_t_mod(sum, ht.sz);
            let c = std::mem::replace::<
                super::pulse_lib_hashtable_spec::cell<KT, VT>,
            >(&mut contents[vidx], super::pulse_lib_hashtable_spec::cell::Zombie);
            match c {
                super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_) => {
                    if k_ == k {
                        contents[vidx] = super::pulse_lib_hashtable_spec::cell::Used(
                            k_,
                            v_,
                        );
                        cont = false;
                        idx = vidx;
                    } else {
                        contents[vidx] = super::pulse_lib_hashtable_spec::cell::Used(
                            k_,
                            v_,
                        );
                        off = voff + 1;
                    }
                }
                super::pulse_lib_hashtable_spec::cell::Clean => {
                    contents[vidx] = super::pulse_lib_hashtable_spec::cell::Clean;
                    cont = false;
                    idx = vidx;
                }
                super::pulse_lib_hashtable_spec::cell::Zombie => {
                    let vcontents = contents;
                    let ht1 = super::pulse_lib_hashtable_type::ht_t {
                        sz: ht.sz,
                        hashf: hashf,
                        contents: vcontents,
                    };
                    let res = super::pulse_lib_hashtable::lookup((), ht1, k);
                    contents = res.0.contents;
                    let o = res.1;
                    match o {
                        Some(mut p) => {
                            contents[p] = super::pulse_lib_hashtable_spec::cell::Zombie;
                            cont = false;
                            idx = vidx;
                        }
                        None => {
                            cont = false;
                            idx = vidx;
                        }
                    }
                }
            }
        }
    }
    let vcont = cont;
    let vidx = idx;
    let _bind_c = if vcont == false {
        contents[vidx] = super::pulse_lib_hashtable::mk_used_cell(k, v);
        let vcontents = contents;
        let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
        let res = (ht1, true);
        res
    } else {
        let vcontents = contents;
        let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
        let res = (ht1, false);
        res
    };
    let idx1 = _bind_c;
    let cont1 = idx1;
    let off1 = cont1;
    let contents1 = off1;
    contents1
}
pub fn is_used<K: Copy + PartialEq + Clone, V: Clone>(
    c: super::pulse_lib_hashtable_spec::cell<K, V>,
) -> (bool, super::pulse_lib_hashtable_spec::cell<K, V>) {
    match c {
        super::pulse_lib_hashtable_spec::cell::Used(_, _) => (true, c),
        _ => (false, c),
    }
}
pub fn not_full<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let mut i = 0;
    while {
        let vi = i;
        if vi < ht.sz {
            let c = std::mem::replace::<
                super::pulse_lib_hashtable_spec::cell<KT, VT>,
            >(&mut contents[vi], super::pulse_lib_hashtable_spec::cell::Zombie);
            let b = super::pulse_lib_hashtable::is_used(c);
            let uu___1 = std::mem::replace::<
                super::pulse_lib_hashtable_spec::cell<KT, VT>,
            >(&mut contents[vi], b.1);
            b.0
        } else {
            false
        }
    } {
        let vi = i;
        i = vi + 1;
    }
    let vi = i;
    let res = vi < ht.sz;
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
    let b = (ht1, res);
    let i1 = b;
    let contents1 = i1;
    contents1
}
pub fn insert_if_not_full<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
    v: VT,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let b = super::pulse_lib_hashtable::not_full(ht, ());
    if b.1 {
        super::pulse_lib_hashtable::insert(b.0, k, v, ())
    } else {
        let res = (b.0, false);
        res
    }
}

