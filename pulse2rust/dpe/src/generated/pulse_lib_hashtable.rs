////
////
//// This file is generated by the Pulse2Rust tool
////
////

pub fn mk_used_cell<A: Copy + PartialEq + Clone, B: Clone>(
    k: A,
    v: B,
) -> super::pulse_lib_hashtable_spec::cell<A, B> {
    super::pulse_lib_hashtable_spec::cell::Used(k, v)
}
pub fn mk_ht<K: Copy + PartialEq + Clone, V: Clone>(
    sz: super::pulse_lib_hashtable_type::pos_us,
    hashf: fn(K) -> usize,
    contents: std::vec::Vec<super::pulse_lib_hashtable_spec::cell<K, V>>,
) -> super::pulse_lib_hashtable_type::ht_t<K, V> {
    super::pulse_lib_hashtable_type::ht_t {
        sz: sz,
        hashf: hashf,
        contents: contents,
    }
}
pub fn alloc<K: Copy + PartialEq + Clone, V: Clone>(
    hashf: fn(K) -> usize,
    l: super::pulse_lib_hashtable_type::pos_us,
) -> super::pulse_lib_hashtable_type::ht_t<K, V> {
    let mut contents = vec![super::pulse_lib_hashtable_spec::cell::Clean; l];
    let ht = super::pulse_lib_hashtable::mk_ht(l, hashf, contents);
    ht
}
pub fn size_t_mod(x: usize, y: usize) -> usize {
    x % y
}
pub fn lookup<KT: Copy + PartialEq + Clone, VT: Clone>(
    pht: (),
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, std::option::Option<usize>) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let cidx = super::pulse_lib_hashtable::size_t_mod(hashf(k), ht.sz);
    let mut off = 0;
    let mut ret = None;
    let mut _break = false;
    while {
        let uu___1 = _break;
        if uu___1 {
            false
        } else {
            let __anf0 = off;
            __anf0 <= ht.sz
        }
    } {
        let voff = off;
        if voff == ht.sz { _break = true } else { () };
        let _break1 = _break;
        if _break1 {} else {
            let sum = cidx + voff;
            let idx = super::pulse_lib_hashtable::size_t_mod(sum, ht.sz);
            let c = std::mem::replace::<
                super::pulse_lib_hashtable_spec::cell<KT, VT>,
            >(&mut contents[idx], super::pulse_lib_hashtable_spec::cell::Zombie);
            match c {
                super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_) => {
                    if k_ == k {
                        ret = Some(idx);
                        let uu___3 = std::mem::replace::<
                            super::pulse_lib_hashtable_spec::cell<KT, VT>,
                        >(
                            &mut contents[idx],
                            super::pulse_lib_hashtable_spec::cell::Used(k_, v_),
                        );
                        _break = true;
                    } else {
                        off = voff + 1;
                        let uu___3 = std::mem::replace::<
                            super::pulse_lib_hashtable_spec::cell<KT, VT>,
                        >(
                            &mut contents[idx],
                            super::pulse_lib_hashtable_spec::cell::Used(k_, v_),
                        );
                    }
                }
                super::pulse_lib_hashtable_spec::cell::Clean => {
                    let uu___2 = std::mem::replace::<
                        super::pulse_lib_hashtable_spec::cell<KT, VT>,
                    >(&mut contents[idx], c);
                    _break = true;
                }
                super::pulse_lib_hashtable_spec::cell::Zombie => {
                    off = voff + 1;
                    let uu___3 = std::mem::replace::<
                        super::pulse_lib_hashtable_spec::cell<KT, VT>,
                    >(&mut contents[idx], c);
                }
            }
        }
    }
    let o = ret;
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, ht.hashf, vcontents);
    (ht1, o)
}
pub fn replace<KT: Copy + PartialEq + Clone, VT: Clone>(
    pht: (),
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    idx: usize,
    k: KT,
    v: VT,
    uu___: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, VT) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let v_ = std::mem::replace::<
        super::pulse_lib_hashtable_spec::cell<KT, VT>,
    >(&mut contents[idx], super::pulse_lib_hashtable::mk_used_cell(k, v));
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
    match v_ {
        super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_1) => (ht1, v_1),
        super::pulse_lib_hashtable_spec::cell::Clean => panic!(),
        super::pulse_lib_hashtable_spec::cell::Zombie => panic!(),
    }
}
pub fn insert<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
    v: VT,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let cidx = super::pulse_lib_hashtable::size_t_mod(hashf(k), ht.sz);
    let mut off = 0;
    let mut idx = 0;
    let mut _break = false;
    while {
        let uu___1 = _break;
        if uu___1 { false } else { true }
    } {
        let voff = off;
        let sum = cidx + voff;
        let vidx = super::pulse_lib_hashtable::size_t_mod(sum, ht.sz);
        let c = std::mem::replace::<
            super::pulse_lib_hashtable_spec::cell<KT, VT>,
        >(&mut contents[vidx], super::pulse_lib_hashtable_spec::cell::Zombie);
        match c {
            super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_) => {
                if k_ == k {
                    contents[vidx] = super::pulse_lib_hashtable_spec::cell::Used(k_, v_);
                    idx = vidx;
                    _break = true;
                } else {
                    contents[vidx] = super::pulse_lib_hashtable_spec::cell::Used(k_, v_);
                    off = voff + 1;
                }
            }
            super::pulse_lib_hashtable_spec::cell::Clean => {
                contents[vidx] = super::pulse_lib_hashtable_spec::cell::Clean;
                idx = vidx;
                _break = true;
            }
            super::pulse_lib_hashtable_spec::cell::Zombie => {
                let vcontents = contents;
                let ht1 = super::pulse_lib_hashtable_type::ht_t {
                    sz: ht.sz,
                    hashf: hashf,
                    contents: vcontents,
                };
                let res = super::pulse_lib_hashtable::lookup((), ht1, k);
                contents = res.0.contents;
                let o = res.1;
                match o {
                    Some(mut p) => {
                        contents[p] = super::pulse_lib_hashtable_spec::cell::Zombie;
                        idx = vidx;
                        _break = true;
                    }
                    None => {
                        idx = vidx;
                        _break = true;
                    }
                }
            }
        }
    }
    let __anf0 = idx;
    contents[__anf0] = super::pulse_lib_hashtable::mk_used_cell(k, v);
    let __anf01 = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, __anf01);
    (ht1, true)
}
pub fn is_used<K: Copy + PartialEq + Clone, V: Clone>(
    c: super::pulse_lib_hashtable_spec::cell<K, V>,
) -> (bool, super::pulse_lib_hashtable_spec::cell<K, V>) {
    match c {
        super::pulse_lib_hashtable_spec::cell::Used(_, _) => (true, c),
        _ => (false, c),
    }
}
pub fn not_full<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let mut i = 0;
    let mut _break = false;
    while {
        let uu___1 = _break;
        if uu___1 {
            false
        } else {
            let __anf0 = i;
            __anf0 < ht.sz
        }
    } {
        let vi = i;
        let c = std::mem::replace::<
            super::pulse_lib_hashtable_spec::cell<KT, VT>,
        >(&mut contents[vi], super::pulse_lib_hashtable_spec::cell::Zombie);
        let b = super::pulse_lib_hashtable::is_used(c);
        let uu___1 = std::mem::replace::<
            super::pulse_lib_hashtable_spec::cell<KT, VT>,
        >(&mut contents[vi], b.1);
        if !b.0 { _break = true } else { () };
        let _break1 = _break;
        if _break1 {} else {
            let __anf0 = i;
            i = __anf0 + 1;
        }
    }
    let __anf0 = i;
    let is_not_full = !(__anf0 == ht.sz);
    let __anf01 = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, __anf01);
    (ht1, is_not_full)
}
pub fn insert_if_not_full<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
    v: VT,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let b = super::pulse_lib_hashtable::not_full(ht, ());
    if b.1 { super::pulse_lib_hashtable::insert(b.0, k, v, ()) } else { (b.0, false) }
}

