////
////
//// This file is generated by the Pulse2Rust tool
////
////

pub fn mk_used_cell<A: Copy + PartialEq + Clone, B: Clone>(
    k: A,
    v: B,
) -> super::pulse_lib_hashtable_spec::cell<A, B> {
    super::pulse_lib_hashtable_spec::cell::Used(k, v)
}
pub fn mk_ht<K: Copy + PartialEq + Clone, V: Clone>(
    sz: super::pulse_lib_hashtable_type::pos_us,
    hashf: fn(K) -> usize,
    contents: std::vec::Vec<super::pulse_lib_hashtable_spec::cell<K, V>>,
) -> super::pulse_lib_hashtable_type::ht_t<K, V> {
    super::pulse_lib_hashtable_type::ht_t {
        sz: sz,
        hashf: hashf,
        contents: contents,
    }
}
pub fn alloc<K: Copy + PartialEq + Clone, V: Clone>(
    hashf: fn(K) -> usize,
    l: super::pulse_lib_hashtable_type::pos_us,
) -> super::pulse_lib_hashtable_type::ht_t<K, V> {
    let mut contents = vec![super::pulse_lib_hashtable_spec::cell::Clean; l];
    let ht = super::pulse_lib_hashtable::mk_ht(l, hashf, contents);
    ht
}
pub fn sz_add(x: usize, y: usize) -> std::option::Option<usize> {
    match x <= 0xffff {
        true => {
            match y <= 0xffff - x {
                true => Some(x + y),
                _ => None,
            }
        }
        _ => None,
    }
}
pub fn size_t_mod(x: usize, y: usize) -> usize {
    x % y
}
pub fn replace<KT: Copy + PartialEq + Clone, VT: Clone>(
    pht: (),
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    idx: usize,
    k: KT,
    v: VT,
    uu___: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, VT) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let v_ = std::mem::replace(
        &mut contents[idx],
        super::pulse_lib_hashtable::mk_used_cell(k, v),
    );
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
    let _bind_c = match v_ {
        super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_1) => {
            let res = (ht1, v_1);
            res
        }
        super::pulse_lib_hashtable_spec::cell::Clean => panic!(),
        super::pulse_lib_hashtable_spec::cell::Zombie => panic!(),
    };
    let contents1 = _bind_c;
    contents1
}
pub fn lookup<KT: Copy + PartialEq + Clone, VT: Clone>(
    pht: (),
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool, std::option::Option<usize>) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let cidx = super::pulse_lib_hashtable::size_t_mod(hashf(k), ht.sz);
    let mut off = 0;
    let mut cont = true;
    let mut err = false;
    let mut ret = None;
    while {
        let voff = off;
        let vcont = cont;
        let verr = err;
        voff <= ht.sz && vcont == true && verr == false
    } {
        let voff = off;
        if voff == ht.sz {
            cont = false;
        } else {
            let opt_sum = super::pulse_lib_hashtable::sz_add(cidx, voff);
            match opt_sum {
                Some(mut sum) => {
                    let idx = super::pulse_lib_hashtable::size_t_mod(sum, ht.sz);
                    let c = std::mem::replace(
                        &mut contents[idx],
                        super::pulse_lib_hashtable_spec::cell::Zombie,
                    );
                    match c {
                        super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_) => {
                            if k_ == k {
                                cont = false;
                                ret = Some(idx);
                                let uu___2 = std::mem::replace(
                                    &mut contents[idx],
                                    super::pulse_lib_hashtable_spec::cell::Used(k_, v_),
                                );
                            } else {
                                off = voff + 1;
                                let uu___1 = std::mem::replace(
                                    &mut contents[idx],
                                    super::pulse_lib_hashtable_spec::cell::Used(k_, v_),
                                );
                            }
                        }
                        super::pulse_lib_hashtable_spec::cell::Clean => {
                            cont = false;
                            let uu___1 = std::mem::replace(&mut contents[idx], c);
                        }
                        super::pulse_lib_hashtable_spec::cell::Zombie => {
                            off = voff + 1;
                            let uu___1 = std::mem::replace(&mut contents[idx], c);
                        }
                    }
                }
                None => err = true,
            }
        };
    }
    let verr = err;
    let o = ret;
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, ht.hashf, vcontents);
    let _bind_c = if verr {
        let res = (ht1, false, o);
        res
    } else {
        let res = (ht1, true, o);
        res
    };
    let ret1 = _bind_c;
    let err1 = ret1;
    let cont1 = err1;
    let off1 = cont1;
    let contents1 = off1;
    contents1
}
pub fn insert<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    k: KT,
    v: VT,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let cidx = super::pulse_lib_hashtable::size_t_mod(hashf(k), ht.sz);
    let mut off = 0;
    let mut cont = true;
    let mut err = false;
    let mut idx = 0;
    while {
        let vcont = cont;
        let verr = err;
        vcont == true && verr == false
    } {
        let voff = off;
        if voff == ht.sz {
            cont = false;
        } else {
            let opt_sum = super::pulse_lib_hashtable::sz_add(cidx, voff);
            match opt_sum {
                Some(mut sum) => {
                    let vidx = super::pulse_lib_hashtable::size_t_mod(sum, ht.sz);
                    let c = std::mem::replace(
                        &mut contents[vidx],
                        super::pulse_lib_hashtable_spec::cell::Zombie,
                    );
                    match c {
                        super::pulse_lib_hashtable_spec::cell::Used(mut k_, mut v_) => {
                            if k_ == k {
                                contents[vidx] = super::pulse_lib_hashtable_spec::cell::Used(
                                    k_,
                                    v_,
                                );
                                cont = false;
                                idx = vidx;
                            } else {
                                contents[vidx] = super::pulse_lib_hashtable_spec::cell::Used(
                                    k_,
                                    v_,
                                );
                                off = voff + 1;
                            }
                        }
                        super::pulse_lib_hashtable_spec::cell::Clean => {
                            contents[vidx] = super::pulse_lib_hashtable_spec::cell::Clean;
                            cont = false;
                            idx = vidx;
                        }
                        super::pulse_lib_hashtable_spec::cell::Zombie => {
                            let vcontents = contents;
                            let ht1 = super::pulse_lib_hashtable_type::ht_t {
                                sz: ht.sz,
                                hashf: hashf,
                                contents: vcontents,
                            };
                            let res = super::pulse_lib_hashtable::lookup((), ht1, k);
                            contents = res.0.contents;
                            if res.1 {
                                let o = res.2;
                                match o {
                                    Some(mut p) => {
                                        contents[p] = super::pulse_lib_hashtable_spec::cell::Zombie;
                                        cont = false;
                                        idx = vidx;
                                    }
                                    None => {
                                        cont = false;
                                        idx = vidx;
                                    }
                                }
                            } else {
                                err = true
                            }
                        }
                    }
                }
                None => err = true,
            }
        };
    }
    let vcont = cont;
    let verr = err;
    let vidx = idx;
    let _bind_c = if vcont == false && verr == false {
        contents[vidx] = super::pulse_lib_hashtable::mk_used_cell(k, v);
        let vcontents = contents;
        let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
        let res = (ht1, true);
        res
    } else {
        let vcontents = contents;
        let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
        let res = (ht1, false);
        res
    };
    let idx1 = _bind_c;
    let err1 = idx1;
    let cont1 = err1;
    let off1 = cont1;
    let contents1 = off1;
    contents1
}
pub fn is_used<K: Copy + PartialEq + Clone, V: Clone>(
    c: super::pulse_lib_hashtable_spec::cell<K, V>,
) -> (bool, super::pulse_lib_hashtable_spec::cell<K, V>) {
    match c {
        super::pulse_lib_hashtable_spec::cell::Used(_, _) => (true, c),
        _ => (false, c),
    }
}
pub fn not_full<KT: Copy + PartialEq + Clone, VT: Clone>(
    ht: super::pulse_lib_hashtable_type::ht_t<KT, VT>,
    pht: (),
) -> (super::pulse_lib_hashtable_type::ht_t<KT, VT>, bool) {
    let hashf = ht.hashf;
    let mut contents = ht.contents;
    let mut i = 0;
    while {
        let vi = i;
        if vi < ht.sz {
            let c = std::mem::replace(
                &mut contents[vi],
                super::pulse_lib_hashtable_spec::cell::Zombie,
            );
            let b = super::pulse_lib_hashtable::is_used(c);
            let uu___ = std::mem::replace(&mut contents[vi], b.1);
            b.0
        } else {
            false
        }
    } {
        let vi = i;
        i = vi + 1;
    }
    let vi = i;
    let res = vi < ht.sz;
    let vcontents = contents;
    let ht1 = super::pulse_lib_hashtable::mk_ht(ht.sz, hashf, vcontents);
    let b = (ht1, res);
    let i1 = b;
    let contents1 = i1;
    contents1
}

