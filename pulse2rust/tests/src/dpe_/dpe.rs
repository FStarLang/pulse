////
////
//// This file is generated by the Pulse2Rust tool
////
////

pub fn run_stt<A>(post: (), f: A) -> A {
    panic!()
}
pub type ctxt_hndl_t = u32;
pub type sid_t = u32;
#[derive(Clone)]
pub struct session_state__Available__payload {
    pub handle: super::dpe::ctxt_hndl_t,
    pub context: super::dpetypes::context_t,
}
#[derive(Clone)]
pub enum session_state {
    SessionStart,
    Available(super::dpe::session_state__Available__payload),
    InUse,
    SessionClosed,
    SessionError,
}
pub type ht_t = super::pulse_lib_hashtable_type::ht_t<
    super::dpe::sid_t,
    super::dpe::session_state,
>;
pub struct st {
    pub st_ctr: super::dpe::sid_t,
    pub st_tbl: super::dpe::ht_t,
}
pub type gref = ();
pub type dpe_t = ((), std::sync::Mutex<std::option::Option<super::dpe::st>>);
pub fn sid_hash(uu___: super::dpe::sid_t) -> usize {
    panic!()
}
pub const fn initialize_global_state(uu___: ()) -> super::dpe::dpe_t {
    let m = std::sync::Mutex::new(None);
    let s = ((), m);
    s
}
pub static global_state: super::dpe::dpe_t = super::dpe::initialize_global_state(());
pub fn safe_add(i: u32, j: u32) -> std::option::Option<u32> {
    panic!()
}
pub fn __open_session(
    r: (),
    s: super::dpe::st,
) -> (super::dpe::st, std::option::Option<super::dpe::sid_t>) {
    let ctr = s.st_ctr;
    let tbl = s.st_tbl;
    let copt = super::dpe::safe_add(ctr, 1);
    match copt {
        None => {
            let s1 = super::dpe::st {
                st_ctr: ctr,
                st_tbl: tbl,
            };
            let ret = (s1, None);
            ret
        }
        Some(mut ctr1) => {
            let ret = super::pulse_lib_hashtable::insert_if_not_full(
                tbl,
                ctr,
                super::dpe::session_state::SessionStart,
                (),
            );
            let tbl1 = ret.0;
            let b = ret.1;
            if b {
                let s1 = super::dpe::st {
                    st_ctr: ctr1,
                    st_tbl: tbl1,
                };
                let ret1 = (s1, Some(ctr));
                ret1
            } else {
                let s1 = super::dpe::st {
                    st_ctr: ctr,
                    st_tbl: tbl1,
                };
                let ret1 = (s1, None);
                ret1
            }
        }
    }
}
pub fn maybe_mk_session_tbl(
    r: (),
    sopt: std::option::Option<super::dpe::st>,
) -> super::dpe::st {
    match sopt {
        None => {
            let tbl = super::pulse_lib_hashtable::alloc(super::dpe::sid_hash, 256);
            let s = super::dpe::st {
                st_ctr: 0,
                st_tbl: tbl,
            };
            s
        }
        Some(mut s) => s,
    }
}
pub fn open_session(
    r: (),
    m: std::sync::Mutex<std::option::Option<super::dpe::st>>,
) -> (
    std::sync::Mutex<std::option::Option<super::dpe::st>>,
    std::option::Option<super::dpe::sid_t>,
) {
    let mut mg = m.lock().unwrap();
    let sopt = std::mem::replace::<std::option::Option<super::dpe::st>>(&mut mg, None);
    let s = super::dpe::maybe_mk_session_tbl((), sopt);
    let ret = super::dpe::__open_session((), s);
    let s1 = ret.0;
    let sid_opt = ret.1;
    *mg = Some(s1);
    std::mem::drop(mg);
    let ret1 = (m, sid_opt);
    ret1
}
pub fn replace_session(
    r: (),
    m: std::sync::Mutex<std::option::Option<super::dpe::st>>,
    sid: super::dpe::sid_t,
    t: (),
    sst: super::dpe::session_state,
    gsst: (),
) -> (std::sync::Mutex<std::option::Option<super::dpe::st>>, super::dpe::session_state) {
    let mut mg = m.lock().unwrap();
    let sopt = std::mem::replace::<std::option::Option<super::dpe::st>>(&mut mg, None);
    match sopt {
        None => panic!(),
        Some(mut s) => {
            let ctr = s.st_ctr;
            let tbl = s.st_tbl;
            if sid < ctr {
                let ret = super::pulse_lib_hashtable::lookup((), tbl, sid);
                let tbl1 = ret.0;
                let b = ret.1;
                let idx = ret.2;
                if b {
                    match idx {
                        Some(mut idx1) => {
                            let ret1 = super::pulse_lib_hashtable::replace(
                                (),
                                tbl1,
                                idx1,
                                sid,
                                sst,
                                (),
                            );
                            let tbl2 = ret1.0;
                            let st1 = ret1.1;
                            let s1 = super::dpe::st {
                                st_ctr: ctr,
                                st_tbl: tbl2,
                            };
                            *mg = Some(s1);
                            std::mem::drop(mg);
                            let ret2 = (m, st1);
                            ret2
                        }
                        None => panic!(),
                    }
                } else {
                    panic!()
                }
            } else {
                panic!()
            }
        }
    }
}
pub fn init_engine_ctxt(
    uds: &mut [u8],
    p: (),
    uds_bytes: (),
) -> super::dpetypes::context_t {
    let mut uds_buf = vec![0; super::enginetypes::uds_len];
    super::pulse_lib_array::memcpy(
        super::enginetypes::uds_len,
        uds,
        &mut uds_buf,
        (),
        (),
        (),
    );
    let engine_context = super::dpetypes::mk_engine_context_t(uds_buf);
    let ctxt = super::dpetypes::mk_context_t_engine(engine_context);
    ctxt
}
pub fn prng(uu___: ()) -> super::dpe::ctxt_hndl_t {
    panic!()
}
pub fn initialize_context(
    r: (),
    m: std::sync::Mutex<std::option::Option<super::dpe::st>>,
    sid: super::dpe::sid_t,
    t: (),
    p: (),
    uds_bytes: (),
    uds: &mut [u8],
) -> (std::sync::Mutex<std::option::Option<super::dpe::st>>, super::dpe::ctxt_hndl_t) {
    let ret = super::dpe::replace_session(
        (),
        m,
        sid,
        (),
        super::dpe::session_state::InUse,
        (),
    );
    let m1 = ret.0;
    let s = ret.1;
    match s {
        super::dpe::session_state::SessionStart => {
            let context = super::dpe::init_engine_ctxt(uds, (), ());
            let handle = super::dpe::prng(());
            let s1 = super::dpe::session_state::Available(super::dpe::session_state__Available__payload {
                handle: handle,
                context: context,
            });
            let ret1 = super::dpe::replace_session((), m1, sid, (), s1, ());
            let m2 = ret1.0;
            let ret2 = (m2, handle);
            ret2
        }
        super::dpe::session_state::InUse => panic!(),
        super::dpe::session_state::SessionClosed => panic!(),
        super::dpe::session_state::SessionError => panic!(),
        super::dpe::session_state::Available(_) => panic!(),
    }
}
pub fn init_l0_ctxt(
    cdi: &mut [u8],
    engine_repr: (),
    s: (),
    uds_bytes: (),
    uu___: (),
) -> super::dpetypes::l0_context_t {
    let mut cdi_buf = vec![0; 32];
    super::pulse_lib_array::memcpy(32, cdi, &mut cdi_buf, (), (), ());
    let l0_context = super::dpetypes::mk_l0_context_t(cdi_buf);
    l0_context
}
pub fn init_l1_ctxt(
    deviceIDCSR_len: usize,
    aliasKeyCRT_len: usize,
    deviceID_priv: &mut [u8],
    deviceID_pub: &mut [u8],
    aliasKey_priv: &mut [u8],
    aliasKey_pub: &mut [u8],
    deviceIDCSR: &mut [u8],
    aliasKeyCRT: &mut [u8],
    deviceID_label_len: (),
    aliasKey_label_len: (),
    cdi: (),
    repr: (),
    deviceIDCSR_ingredients: (),
    aliasKeyCRT_ingredients: (),
    deviceID_priv0: (),
    deviceID_pub0: (),
    aliasKey_priv0: (),
    aliasKey_pub0: (),
    deviceIDCSR0: (),
    aliasKeyCRT0: (),
    uu___: (),
) -> super::dpetypes::l1_context_t {
    let mut deviceID_pub_buf = vec![0; 32];
    let mut deviceID_priv_buf = vec![0; 32];
    let mut aliasKey_priv_buf = vec![0; 32];
    let mut aliasKey_pub_buf = vec![0; 32];
    let mut deviceIDCSR_buf = vec![0; deviceIDCSR_len];
    let mut aliasKeyCRT_buf = vec![0; aliasKeyCRT_len];
    super::pulse_lib_array::memcpy(
        32,
        deviceID_priv,
        &mut deviceID_priv_buf,
        (),
        (),
        (),
    );
    super::pulse_lib_array::memcpy(32, deviceID_pub, &mut deviceID_pub_buf, (), (), ());
    super::pulse_lib_array::memcpy(
        32,
        aliasKey_priv,
        &mut aliasKey_priv_buf,
        (),
        (),
        (),
    );
    super::pulse_lib_array::memcpy(32, aliasKey_pub, &mut aliasKey_pub_buf, (), (), ());
    super::pulse_lib_array::memcpy(
        deviceIDCSR_len,
        deviceIDCSR,
        &mut deviceIDCSR_buf,
        (),
        (),
        (),
    );
    super::pulse_lib_array::memcpy(
        aliasKeyCRT_len,
        aliasKeyCRT,
        &mut aliasKeyCRT_buf,
        (),
        (),
        (),
    );
    let l1_context = super::dpetypes::mk_l1_context_t(
        deviceID_priv_buf,
        deviceID_pub_buf,
        aliasKey_priv_buf,
        aliasKey_pub_buf,
        aliasKeyCRT_buf,
        deviceIDCSR_buf,
    );
    l1_context
}
pub fn derive_child_from_context(
    context: super::dpetypes::context_t,
    record: super::dpetypes::record_t,
    p: (),
    record_repr: (),
    context_repr: (),
    uu___: (),
) -> (
    super::dpetypes::context_t,
    super::dpetypes::record_t,
    std::option::Option<super::dpetypes::context_t>,
) {
    match context {
        super::dpetypes::context_t::Engine_context(mut c) => {
            match record {
                super::dpetypes::record_t::Engine_record(mut r) => {
                    let cdi = &mut [0; 32];
                    let ret = super::enginecore::engine_main(
                        cdi,
                        &mut c.uds,
                        r,
                        (),
                        (),
                        (),
                        (),
                        (),
                    );
                    let r1 = ret.0;
                    let _bind_c = match ret.1 {
                        super::enginetypes::dice_return_code::DICE_SUCCESS => {
                            let l0_ctxt = super::dpe::init_l0_ctxt(cdi, (), (), (), ());
                            let ret1 = (
                                super::dpetypes::context_t::Engine_context(c),
                                super::dpetypes::record_t::Engine_record(r1),
                                Some(super::dpetypes::context_t::L0_context(l0_ctxt)),
                            );
                            ret1
                        }
                        super::enginetypes::dice_return_code::DICE_ERROR => {
                            super::pulse_lib_array::zeroize(32, cdi, ());
                            let ret1 = (
                                super::dpetypes::context_t::Engine_context(c),
                                super::dpetypes::record_t::Engine_record(r1),
                                None,
                            );
                            ret1
                        }
                    };
                    let cdi1 = _bind_c;
                    cdi1
                }
                super::dpetypes::record_t::L0_record(_) => panic!(),
            }
        }
        super::dpetypes::context_t::L0_context(mut c) => {
            match record {
                super::dpetypes::record_t::L0_record(mut r) => {
                    let deviceIDCRI_len_and_ing = super::x509::len_of_deviceIDCRI(
                        r.deviceIDCSR_ingredients,
                    );
                    let deviceIDCSR_ingredients = deviceIDCRI_len_and_ing.0;
                    let deviceIDCRI_len = deviceIDCRI_len_and_ing.1;
                    let aliasKeyTBS_len_and_ing = super::x509::len_of_aliasKeyTBS(
                        r.aliasKeyCRT_ingredients,
                    );
                    let aliasKeyCRT_ingredients = aliasKeyTBS_len_and_ing.0;
                    let aliasKeyTBS_len = aliasKeyTBS_len_and_ing.1;
                    let deviceIDCSR_len = super::x509::length_of_deviceIDCSR(
                        deviceIDCRI_len,
                    );
                    let aliasKeyCRT_len = super::x509::length_of_aliasKeyCRT(
                        aliasKeyTBS_len,
                    );
                    let deviceID_pub = &mut [0; 32];
                    let deviceID_priv = &mut [0; 32];
                    let aliasKey_pub = &mut [0; 32];
                    let aliasKey_priv = &mut [0; 32];
                    let mut deviceIDCSR = vec![0; deviceIDCSR_len];
                    let mut aliasKeyCRT = vec![0; aliasKeyCRT_len];
                    let r1 = super::l0types::l0_record_t {
                        fwid: r.fwid,
                        deviceID_label_len: r.deviceID_label_len,
                        deviceID_label: r.deviceID_label,
                        aliasKey_label_len: r.aliasKey_label_len,
                        aliasKey_label: r.aliasKey_label,
                        deviceIDCSR_ingredients: deviceIDCSR_ingredients,
                        aliasKeyCRT_ingredients: aliasKeyCRT_ingredients,
                    };
                    let r2 = super::l0core::l0_main(
                        &mut c.cdi,
                        deviceID_pub,
                        deviceID_priv,
                        aliasKey_pub,
                        aliasKey_priv,
                        aliasKeyTBS_len,
                        aliasKeyCRT_len,
                        &mut aliasKeyCRT,
                        deviceIDCRI_len,
                        deviceIDCSR_len,
                        &mut deviceIDCSR,
                        r1,
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                    );
                    let l1_context = super::dpe::init_l1_ctxt(
                        deviceIDCSR_len,
                        aliasKeyCRT_len,
                        deviceID_priv,
                        deviceID_pub,
                        aliasKey_priv,
                        aliasKey_pub,
                        &mut deviceIDCSR,
                        &mut aliasKeyCRT,
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                        (),
                    );
                    drop(deviceIDCSR);
                    drop(aliasKeyCRT);
                    let ret = (
                        super::dpetypes::context_t::L0_context(c),
                        super::dpetypes::record_t::L0_record(r2),
                        Some(super::dpetypes::context_t::L1_context(l1_context)),
                    );
                    let aliasKey_priv1 = ret;
                    let aliasKey_pub1 = aliasKey_priv1;
                    let deviceID_priv1 = aliasKey_pub1;
                    let deviceID_pub1 = deviceID_priv1;
                    deviceID_pub1
                }
                super::dpetypes::record_t::Engine_record(_) => panic!(),
            }
        }
        super::dpetypes::context_t::L1_context(_) => panic!(),
    }
}
pub fn destroy_ctxt(ctxt: super::dpetypes::context_t, repr: ()) -> () {
    match ctxt {
        super::dpetypes::context_t::Engine_context(mut c) => drop(c.uds),
        super::dpetypes::context_t::L0_context(mut c) => drop(c.cdi),
        super::dpetypes::context_t::L1_context(mut c) => {
            drop(c.deviceID_priv);
            drop(c.deviceID_pub);
            drop(c.aliasKey_priv);
            drop(c.aliasKey_pub);
            drop(c.aliasKeyCRT);
            drop(c.deviceIDCSR)
        }
    }
}
pub fn derive_child(
    r: (),
    m: std::sync::Mutex<std::option::Option<super::dpe::st>>,
    sid: super::dpe::sid_t,
    ctxt_hndl: super::dpe::ctxt_hndl_t,
    t: (),
    record: super::dpetypes::record_t,
    rrepr: (),
    p: (),
) -> (
    std::sync::Mutex<std::option::Option<super::dpe::st>>,
    super::dpetypes::record_t,
    std::option::Option<super::dpe::ctxt_hndl_t>,
) {
    let ret = super::dpe::replace_session(
        (),
        m,
        sid,
        (),
        super::dpe::session_state::InUse,
        (),
    );
    let m1 = ret.0;
    let s = ret.1;
    match s {
        super::dpe::session_state::Available(mut hc) => {
            match hc.context {
                super::dpetypes::context_t::L1_context(_) => panic!(),
                _ => {
                    let ret1 = super::dpe::derive_child_from_context(
                        hc.context,
                        record,
                        (),
                        (),
                        (),
                        (),
                    );
                    let octxt = ret1.0;
                    let record1 = ret1.1;
                    let nctxt = ret1.2;
                    super::dpe::destroy_ctxt(octxt, ());
                    match nctxt {
                        Some(mut nctxt1) => {
                            let handle = super::dpe::prng(());
                            let s1 = super::dpe::session_state::Available(super::dpe::session_state__Available__payload {
                                handle: handle,
                                context: nctxt1,
                            });
                            let ret2 = super::dpe::replace_session(
                                (),
                                m1,
                                sid,
                                (),
                                s1,
                                (),
                            );
                            let m2 = ret2.0;
                            let ret3 = (m2, record1, Some(handle));
                            ret3
                        }
                        None => {
                            let s1 = super::dpe::session_state::SessionError;
                            let ret2 = super::dpe::replace_session(
                                (),
                                m1,
                                sid,
                                (),
                                s1,
                                (),
                            );
                            let m2 = ret2.0;
                            let ret3 = (m2, record1, None);
                            ret3
                        }
                    }
                }
            }
        }
        super::dpe::session_state::SessionStart => panic!(),
        super::dpe::session_state::InUse => panic!(),
        super::dpe::session_state::SessionClosed => panic!(),
        super::dpe::session_state::SessionError => panic!(),
    }
}
pub fn destroy_session_state(s: super::dpe::session_state, t: ()) -> () {
    match s {
        super::dpe::session_state::Available(mut hc) => {
            super::dpe::destroy_ctxt(hc.context, ())
        }
        _ => {}
    }
}
pub fn close_session(
    r: (),
    m: std::sync::Mutex<std::option::Option<super::dpe::st>>,
    sid: super::dpe::sid_t,
    t: (),
) -> std::sync::Mutex<std::option::Option<super::dpe::st>> {
    let ret = super::dpe::replace_session(
        (),
        m,
        sid,
        (),
        super::dpe::session_state::InUse,
        (),
    );
    let m1 = ret.0;
    let s = ret.1;
    super::dpe::destroy_session_state(s, ());
    let ret1 = super::dpe::replace_session(
        (),
        m1,
        sid,
        (),
        super::dpe::session_state::SessionClosed,
        (),
    );
    let m2 = ret1.0;
    m2
}
pub fn get_profile(uu___: ()) -> super::dpetypes::profile_descriptor_t {
    super::dpetypes::mk_profile_descriptor(
        "".to_string(),
        1,
        0,
        false,
        false,
        false,
        false,
        0,
        "".to_string(),
        false,
        "".to_string(),
        "".to_string(),
        false,
        true,
        1,
        16,
        false,
        false,
        false,
        false,
        true,
        false,
        false,
        false,
        false,
        false,
        true,
        false,
        false,
        false,
        false,
        false,
        true,
        "".to_string(),
        "".to_string(),
        "".to_string(),
        false,
        "".to_string(),
        "".to_string(),
        "".to_string(),
        false,
        false,
        false,
        "".to_string(),
        "".to_string(),
        "".to_string(),
        false,
        0,
        0,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        "".to_string(),
        false,
        "".to_string(),
        "".to_string(),
        "".to_string(),
        false,
        "".to_string(),
        "".to_string(),
        false,
        false,
        false,
        "".to_string(),
    )
}

