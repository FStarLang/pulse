////
////
//// This file is generated by the Pulse2Rust tool
////
////

pub fn derive_key_pair_aux(
    pubk: &mut [u8],
    privk: &mut [u8],
    ikm_len: super::hacl::hkdf_ikm_len,
    ikm: &mut [u8],
    lbl_len: super::hacl::hkdf_lbl_len,
    lbl: &mut [u8],
    ikm_perm: (),
    lbl_perm: (),
    _pub_seq: (),
    _priv_seq: (),
    ikm_seq: (),
    lbl_seq: (),
) -> () {
    panic!()
}
pub static derive_key_pair: fn(
    &mut [u8],
    &mut [u8],
    super::hacl::hkdf_ikm_len,
    &mut [u8],
    super::hacl::hkdf_lbl_len,
    &mut [u8],
    (),
    (),
    (),
    (),
    (),
    (),
) -> () = super::l0crypto::derive_key_pair_aux;
pub fn derive_DeviceID_aux(
    alg: super::hacl::alg_t,
    deviceID_pub: &mut [u8],
    deviceID_priv: &mut [u8],
    cdi: &mut [u8],
    deviceID_label_len: super::hacl::hkdf_lbl_len,
    deviceID_label: &mut [u8],
    cdi0: (),
    deviceID_label0: (),
    deviceID_pub0: (),
    deviceID_priv0: (),
    cdi_perm: (),
    p: (),
) -> () {
    let mut cdigest = vec![0; super::hacl::digest_len(alg)];
    super::hacl::hacl_hash(
        alg,
        super::hacl::dice_digest_len,
        cdi,
        &mut cdigest,
        (),
        (),
        (),
    );
    super::l0crypto::derive_key_pair(
        deviceID_pub,
        deviceID_priv,
        super::hacl::digest_len(alg),
        &mut cdigest,
        deviceID_label_len,
        deviceID_label,
        (),
        (),
        (),
        (),
        (),
        (),
    );
    drop(cdigest)
}
pub static derive_DeviceID: fn(
    super::hacl::alg_t,
    &mut [u8],
    &mut [u8],
    &mut [u8],
    super::hacl::hkdf_lbl_len,
    &mut [u8],
    (),
    (),
    (),
    (),
    (),
    (),
) -> () = super::l0crypto::derive_DeviceID_aux;
pub fn derive_AliasKey_aux(
    alg: super::hacl::alg_t,
    aliasKey_pub: &mut [u8],
    aliasKey_priv: &mut [u8],
    cdi: &mut [u8],
    fwid: &mut [u8],
    aliasKey_label_len: super::hacl::hkdf_lbl_len,
    aliasKey_label: &mut [u8],
    cdi0: (),
    fwid0: (),
    aliasKey_label0: (),
    aliasKey_pub0: (),
    aliasKey_priv0: (),
    cdi_perm: (),
    p: (),
) -> () {
    let mut cdigest = vec![0; super::hacl::digest_len(alg)];
    let mut adigest = vec![0; super::hacl::digest_len(alg)];
    super::hacl::hacl_hash(
        alg,
        super::hacl::dice_digest_len,
        cdi,
        &mut cdigest,
        (),
        (),
        (),
    );
    super::hacl::hacl_hmac(
        alg,
        &mut adigest,
        &mut cdigest,
        super::hacl::digest_len(alg),
        fwid,
        super::hacl::v32us,
        (),
        (),
        (),
        (),
        (),
    );
    super::l0crypto::derive_key_pair(
        aliasKey_pub,
        aliasKey_priv,
        super::hacl::digest_len(alg),
        &mut adigest,
        aliasKey_label_len,
        aliasKey_label,
        (),
        (),
        (),
        (),
        (),
        (),
    );
    drop(cdigest);
    drop(adigest)
}
pub static derive_AliasKey: fn(
    super::hacl::alg_t,
    &mut [u8],
    &mut [u8],
    &mut [u8],
    &mut [u8],
    super::hacl::hkdf_lbl_len,
    &mut [u8],
    (),
    (),
    (),
    (),
    (),
    (),
    (),
) -> () = super::l0crypto::derive_AliasKey_aux;
pub fn derive_AuthKeyID_aux(
    alg: super::hacl::alg_t,
    authKeyID: &mut [u8],
    deviceID_pub: &mut [u8],
    authKeyID0: (),
    deviceID_pub0: (),
    p: (),
) -> () {
    super::hacl::hacl_hash(alg, super::hacl::v32us, deviceID_pub, authKeyID, (), (), ())
}
pub static derive_AuthKeyID: fn(
    super::hacl::alg_t,
    &mut [u8],
    &mut [u8],
    (),
    (),
    (),
) -> () = super::l0crypto::derive_AuthKeyID_aux;

